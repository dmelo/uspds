/**************************************************************************
   NET NAME    : default 
   GENERATED AT: Tue Nov 30 15:38:20 2004

   SNNS VERSION: V1.4-3D
   PURPOSE     : contain the network initializations and pattern
                 propagating functions
   NOTES       : this file is generated by snns2c

   UPDATE FUNC : Serial_Order
   LEARN FUNC  : Std_Backpropagation

   AUTHOR      : Kais Brahim
   CHANGED BY  : Dietmar Posselt
   VERSION     : 1.0

             Copyright (c) 1990-1993  SNNS Group, IPVR, Univ. Stuttgart, FRG

*****************************************************************************/ 
 
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <stdarg.h>

#include <math.h>




#include "futbot.h"

#define     DEF_ACT_FUNC       (ActFuncPtr)ACT_Logistic
#define     DEF_OUT_FUNC       (OutFuncPtr)OUT_IDENTITY



/**************************************************************************
   FILE           : snns2c.src1
   SNNS VERSION   : 2.1

   PURPOSE        : Type Definitions and Macros for C Network runtime.c

   AUTHOR         : Kais Brahim
   VERSION        : 1.0
   CHANGED BY     : Dietmar Posselt

   DATE           : 15.11.92

             Copyright (c) 1990-1993  SNNS Group, IPVR, Univ. Stuttgart, FRG

*****************************************************************************/


 /* Unit-Flags */

#define  UFLAG_INITIALIZED 0x0007
#define  UFLAG_REFRESH     0x0008

#define  UFLAG_TTYP_IN     0x0010
#define  UFLAG_TTYP_OUT    0x0020
#define  UFLAG_TTYP_DUAL   0x0030
#define  UFLAG_TTYP_HIDD   0x0040
#define  UFLAG_TTYP_SPEC   0x0080

#define  UFLAG_INPUT_PAT   0x0300
#define  UFLAG_NO_INP      0x0000
#define  UFLAG_SITES       0x0100
#define  UFLAG_DLINKS      0x0200


/* ERRORS  */

#define  NO_ERR           0
#define  ERR_SYNTAX       -1
#define  ERR_MEMORY       -2
#define  ERR_FTYPE        -3
#define  ERR_SITE         -5
#define  ERR_UNIT         -6
#define  ERR_IO           -7
#define  ERR_PATTERN      -8
#define  ERR_TOPOMODE     -9
#define  ERR_FUNC         -10
#define  ERR_FILE_OPEN    -11


#define  EOS              '\0'
#define  FALSE            0
#define  TRUE             1
#define  OUT_IDENTITY     (OutFuncPtr)NULL





typedef   float     FlintType;

typedef  FlintType   (* OutFuncPtr) (register FlintType);
typedef  FlintType   (* ActFuncPtr) (struct Unit*);
typedef  FlintType   (* SiteFuncPtr)(struct Site*);
typedef  void        (* FunctionPtr)  ();

typedef  unsigned short  FlagWord;

//typedef  int     bool;
typedef  int     net_error;



/*#################################################

   Type Definition of Unit Functionality

#################################################*/

struct   FtypeUnitStruct
  {
  char            *type_name;
  OutFuncPtr      out_func;
  ActFuncPtr      act_func;
  struct Site     *sites;
  };



/*#################################################

   Type Definition of Site-Table

#################################################*/

struct   SiteTable
  {
    char        *site_name;
    SiteFuncPtr   site_func;      /*  site function    */
  };


/*#################################################

GROUP: Unit/Site/Link type definitions

#################################################*/


struct   Link
  {
  struct Unit   *to;
  FlintType     weight;
  };


struct   Site
  {
  struct Link      *links;
  struct SiteTable *site_table;       /* site table entry*/
  struct Site      *next;
  };




struct   Unit
  {
  char            *unit_name;        /*  unit name              */

  FlintType       output,            /*  output                 */
		  act,               /*  activation             */
		  i_act,             /*  initial activation     */
		  bias;              /*  bias                   */

  FlagWord        flags;             /*  unit state identifier  */

  struct          FtypeUnitStruct   *Ftype_entry;

  OutFuncPtr    out_func;          /*  output function        */
  ActFuncPtr    act_func;          /*  activation function    */

  struct Site     *sites;
  };



/*#################################################

	 Type Definition of Function Table

#################################################*/



struct  FuncTable
  {
  char    *func_name;                 /*  name of the function  */
  FunctionPtr  function;              /*  pointer to the function  */
  };





/*#################################################

 Link/Site/Unit and Unit Ptrs Array Type Definitions

#################################################*/


/* Definition of Site Name Table Array
*/
typedef   struct SiteTable *STableArray;

/*  definition of pointer array for topological sorting
*/
typedef  struct Unit **TopoPtrArray;

/*  definition of unit array
*/
typedef  struct Unit    *UnitArray;

/*  definition of link array
*/
typedef  struct Link    *LinkArray;


/* definition of Ftype Unit
*/
typedef struct FtypeUnitStruct   *FtypeArray;



#define FOR_ALL_UNITS( unit_ptr )  \
for ((unit_ptr) = unit_array + MIN_UNIT_NO; \
     (unit_ptr) <= unit_array + MAX_UNIT_NO; (unit_ptr)++)

#define FOR_ALL_SITES( unit_ptr, site_ptr )  \
for ((site_ptr) = (unit_ptr)->sites; (site_ptr) != NULL; \
     (site_ptr) = (site_ptr)->next)

#define FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr ) \
for ((site_ptr) = (unit_ptr)->sites; (site_ptr) != NULL; \
     (site_ptr) = (site_ptr)->next) \
  for ((link_ptr) = (site_ptr)->links; (link_ptr->to) != NULL; \
       link_ptr++)

#define FOR_ALL_LINKS( unit_ptr, link_ptr )  \
for ((link_ptr) = (struct Link *) (unit_ptr)->sites; (link_ptr->to) != NULL; \
     link_ptr++)


/*  Some useful macros to determine the input type of a given unit
*/
#define UNIT_HAS_SITES( unit_ptr )  \
((unit_ptr)->flags & UFLAG_SITES)

#define UNIT_HAS_DIRECT_INPUTS( unit_ptr ) \
((unit_ptr)->flags & UFLAG_DLINKS)


#define  UNIT_PTR   struct Unit *
#define  SITE_PTR   struct Site *

#define  ACT_FUNC_DEFS      register struct Link  *__link_ptr; \
                            register struct Site  *__site_ptr;

#define  SITE_FUNC_DEFS     register struct Link  *__link_ptr;


/*#################################################

       Link Macros

#################################################*/

#define  GET_FIRST_UNIT_LINK( u_ptr )   (__link_ptr = ( (u_ptr)->flags & UFLAG_DLINKS) ? \
					 ( (struct Link *) (u_ptr)->sites) : (NULL) )

#define  GET_FIRST_SITE_LINK( s_ptr )   (__link_ptr = (s_ptr)->links)

#define  GET_NEXT_LINK      ((++__link_ptr)->to)

#define  GET_WEIGHTED_OUTPUT    ( (__link_ptr->weight) * (__link_ptr->to->output) )

#define  GET_OUTPUT         (__link_ptr->to->output)

#define  GET_WEIGHT         (__link_ptr->weight)


/*#################################################

       Site Macros

#################################################*/

#define  GET_FIRST_SITE( u_ptr )    (__site_ptr = ( (u_ptr)->flags & UFLAG_SITES) ? \
                                     ( (u_ptr)->sites ) : (NULL) )

#define  GET_NEXT_SITE      (__site_ptr = __site_ptr->next)

#define  GET_SITE_NAME      (__site_ptr->site_table->site_name)

#define  GET_SITE_VALUE     ( (*__site_ptr->site_table->site_func) (__site_ptr) )

/*  Future Application (in SNNS-Kernel V1.4 the sites don't have weights).
*/
#define  GET_SITE_WEIGHT    ((FlintType) 1)


/*#################################################

      Unit Macros

#################################################*/

#define  GET_UNIT_BIAS( u_ptr )  ((u_ptr)->bias)
#define  GET_UNIT_ACT( u_ptr )   ((u_ptr)->act)


/*************************************************************************

                       my_strdup

*************************************************************************/

char *my_strdup (char *string)
{
int i;
char *ret;
ret = (char *) malloc ((1+strlen(string)) * sizeof(char));
strcpy (ret, string);
return ret;
}

char *err_chk();
net_error Init_Net();
void Init_SiteTypes();
void Init_UnitTypes();
void Init_Units();
void Init_Connect();
struct Unit *set_CurrentUnit(int);
void Set_Site(struct SiteTable **,char *,SiteFuncPtr);
void Set_SiteEntry();
void Set_FuncType(struct FtypeUnitStruct *,char *,ActFuncPtr ,OutFuncPtr );
void Set_Unit(int no, ...);
void Set_UnitTop();
void Set_Links(struct Link **link, ...);
void  Sort_Net();
void  clear_flags();
void  DepthFirstT();
void  TopoSortT();
void  DepthFirstFF();
void  TopoSortFF();
void  TopoSortIHO();
bool  NextInput();
void  create_PatOutHeader();
net_error Load_Pattern_File();
void  Show_Pattern();
net_error  Propagate_Pattern_Array();
net_error  Propagate_Pattern();
void  cutTrailingZeros();
net_error  Open_Out_File();
net_error  Write_Pattern_Arrays();
net_error  Write_Pattern();
net_error AllocMem();
FlintType  OUT_Identity(register FlintType);
FlintType  OUT_Clip_01(register FlintType );
FlintType  OUT_Clip_11(register FlintType );
FlintType  OUT_Threshold05(register FlintType );
FlintType  ACT_Linear(UNIT_PTR );
FlintType  ACT_MinOutPlusWeight(UNIT_PTR );
FlintType  ACT_TanHFunction(UNIT_PTR );
FlintType  ACT_Logistic(UNIT_PTR );
FlintType  ACT_Perceptron(UNIT_PTR );
FlintType  ACT_Signum(UNIT_PTR );
FlintType  ACT_Signum0(UNIT_PTR );
FlintType  ACT_StepFunction(UNIT_PTR );
FlintType  ACT_BAMFunction(UNIT_PTR );
FlintType  ACT_LogisticI(UNIT_PTR );
FlintType  RbfUnitGetNormsqr(UNIT_PTR);
FlintType  ACT_RBF_Gaussian(UNIT_PTR);
FlintType  ACT_RBF_Thinplatespline(UNIT_PTR);
FlintType  ACT_Linear_bias(UNIT_PTR);
FlintType  SITE_WeightedSum(SITE_PTR);
FlintType  SITE_Product(SITE_PTR);
FlintType  SITE_ProductA(SITE_PTR);
FlintType  SITE_Max(SITE_PTR);
FlintType  SITE_Min(SITE_PTR);
void  UPDATE_syncPropagate();
void  UPDATE_topologicalPropagate();
void  UPDATE_serialPropagate();
void  UPDATE_randomOrderPropagate();
void  UPDATE_randomPermutPropagate();
void  UPDATE_CPNPropagate();



FtypeArray        FTypeEntry;
UnitArray         unit_array;
STableArray       site_array;
LinkArray         link_array;

TopoPtrArray topo_ptr_array, topo_ptr;

int          no_of_patterns = 0;
bool         append = FALSE;
net_error    error = 0;


char              *patHeader[] = {
	/*pattern input file headers */

	"SNNS pattern definition file %s\n",
	"generated at",
	"No. of patterns     : %d\n",
	"No. of input units  : %d\n",
	"No. of output units : %d\n",

	/* pattern result file headers */

	"SNNS result file",
	"startpattern        : ",
	"No. of patterns     : ",
	"No. of input units  : ",
	"No. of output units : ",
	"input patterns included",
	"input patterns excluded",
	};



/***********************************************************************

			Net Initialization Functions

************************************************************************/




/* read unit definition section */

void Init_Units()
{
   char str[40] ,st;
   int i, no;
   float flt;
   bool SIT;

   FunctionPtr      func_ptr;

   struct FtypeUnitStruct *F_ptr;
   struct SiteTable *site_entry;
   struct Site *site_ptr, *ftype_site;



   Set_Unit(1, NULL, "noName", 0.350910, -0.233010, (int) 'i', NULL, NULL,NULL);
   Set_Unit(2, NULL, "noName", 0.389140, -0.111670, (int) 'i', NULL, NULL,NULL);
   Set_Unit(3, NULL, "noName", 1.596640, -0.798640, (int) 'i', NULL, NULL,NULL);
   Set_Unit(4, NULL, "noName", 1.912740, 0.093600, (int) 'i', NULL, NULL,NULL);
   Set_Unit(5, NULL, "noName", 1.689090, 0.336160, (int) 'i', NULL, NULL,NULL);
   Set_Unit(6, NULL, "noName", 2.094320, -0.388530, (int) 'i', NULL, NULL,NULL);
   Set_Unit(7, NULL, "noName", 1.687470, 0.494000, (int) 'i', NULL, NULL,NULL);
   Set_Unit(8, NULL, "noName", 1.720680, 0.567740, (int) 'i', NULL, NULL,NULL);
   Set_Unit(9, NULL, "noName", 1.884570, 0.642810, (int) 'i', NULL, NULL,NULL);
   Set_Unit(10, NULL, "noName", 2.093130, -0.851130, (int) 'i', NULL, NULL,NULL);
   Set_Unit(11, NULL, "noName", 0.342400, -0.423570, (int) 'i', NULL, NULL,NULL);
   Set_Unit(12, NULL, "noName", 0.081500, -0.962520, (int) 'i', NULL, NULL,NULL);
   Set_Unit(13, NULL, "noName", 2.394700, -0.320110, (int) 'i', NULL, NULL,NULL);
   Set_Unit(14, NULL, "noName", 1.911540, -0.094640, (int) 'i', NULL, NULL,NULL);
   Set_Unit(15, NULL, "noName", 2.310920, 0.082670, (int) 'i', NULL, NULL,NULL);
   Set_Unit(16, NULL, "noName", 1.719770, 0.054900, (int) 'i', NULL, NULL,NULL);
   Set_Unit(17, NULL, "noName", 2.302880, 0.429120, (int) 'i', NULL, NULL,NULL);
   Set_Unit(18, NULL, "noName", 2.094600, 0.022740, (int) 'i', NULL, NULL,NULL);
   Set_Unit(19, NULL, "noName", 2.108580, -0.673390, (int) 'i', NULL, NULL,NULL);
   Set_Unit(20, NULL, "noName", 1.721460, -0.539230, (int) 'i', NULL, NULL,NULL);
   Set_Unit(21, NULL, "noName", 2.104580, -0.978700, (int) 'i', NULL, NULL,NULL);
   Set_Unit(22, NULL, "noName", 2.093810, -0.851440, (int) 'i', NULL, NULL,NULL);
   Set_Unit(23, NULL, "noName", 0.551900, -0.640900, (int) 'h', NULL, NULL,NULL);
   Set_Unit(24, NULL, "noName", 0.130710, -0.204330, (int) 'h', NULL, NULL,NULL);
   Set_Unit(25, NULL, "noName", 0.000170, -0.751380, (int) 'h', NULL, NULL,NULL);
   Set_Unit(26, NULL, "noName", 0.885380, 1.623090, (int) 'h', NULL, NULL,NULL);
   Set_Unit(27, NULL, "noName", 0.511370, 0.912970, (int) 'h', NULL, NULL,NULL);
   Set_Unit(28, NULL, "noName", 0.335780, 0.412640, (int) 'h', NULL, NULL,NULL);
   Set_Unit(29, NULL, "noName", 0.012930, 0.156200, (int) 'h', NULL, NULL,NULL);
   Set_Unit(30, NULL, "noName", 0.221070, -0.598550, (int) 'h', NULL, NULL,NULL);
   Set_Unit(31, NULL, "noName", 0.076400, -2.366770, (int) 'h', NULL, NULL,NULL);
   Set_Unit(32, NULL, "noName", 0.788170, -0.354880, (int) 'h', NULL, NULL,NULL);
   Set_Unit(33, NULL, "noName", 0.000060, -0.053580, (int) 'h', NULL, NULL,NULL);
   Set_Unit(34, NULL, "noName", 0.999840, 0.839380, (int) 'h', NULL, NULL,NULL);
   Set_Unit(35, NULL, "noName", 0.961110, 0.466020, (int) 'h', NULL, NULL,NULL);
   Set_Unit(36, NULL, "noName", 0.000160, -0.373270, (int) 'h', NULL, NULL,NULL);
   Set_Unit(37, NULL, "noName", 0.009800, -3.519760, (int) 'h', NULL, NULL,NULL);
   Set_Unit(38, NULL, "noName", 0.952750, 0.811300, (int) 'h', NULL, NULL,NULL);
   Set_Unit(39, NULL, "noName", 0.227360, -0.550800, (int) 'h', NULL, NULL,NULL);
   Set_Unit(40, NULL, "noName", 0.533740, -0.322300, (int) 'h', NULL, NULL,NULL);
   Set_Unit(41, NULL, "noName", 0.000040, 0.353750, (int) 'h', NULL, NULL,NULL);
   Set_Unit(42, NULL, "noName", 0.003370, 0.264260, (int) 'h', NULL, NULL,NULL);
   Set_Unit(43, NULL, "noName", 0.000210, -0.035520, (int) 'h', NULL, NULL,NULL);
   Set_Unit(44, NULL, "noName", 0.001900, 0.768810, (int) 'h', NULL, NULL,NULL);
   Set_Unit(45, NULL, "noName", 0.333860, -1.057070, (int) 'o', NULL, NULL,NULL);
   Set_Unit(46, NULL, "noName", 0.134860, -1.128670, (int) 'o', NULL, NULL,NULL);
}


void Init_Connect()
{
   struct Link *link_ptr;

   link_ptr = link_array;



  Set_Links(&link_ptr, 23, NULL,
"22:-0.308490","21:-0.382360","20:-0.445900","19:-0.279520","18:0.183300","17:0.264080","16:0.842470","15:0.027010","14:-0.021680",
"13:-0.512010","12:-1.731580","11:1.695700","10:0.741190","9:0.642570","8:-1.134400","7:-0.821940","6:0.873190","5:-0.076980",
"4:0.028750","3:0.161540","2:-0.002270","1:1.559940", NULL);

  Set_Links(&link_ptr, 24, NULL,
"22:0.957160","21:-0.498780","20:0.459820","19:-0.829340","18:0.820730","17:-0.094030","16:0.051070","15:-0.073620","14:0.527240",
"13:-0.599170","12:-0.218230","11:0.306370","10:-0.690600","9:-0.832420","8:-0.180080","7:0.057010","6:0.564260","5:0.865600",
"4:-0.557080","3:-0.483450","2:-0.331220","1:-0.619810", NULL);

  Set_Links(&link_ptr, 25, NULL,
"22:0.204400","21:-1.085640","20:0.796130","19:0.602610","18:0.372660","17:-0.167740","16:-0.607280","15:-0.941920","14:0.321780",
"13:-0.707700","12:-0.842380","11:0.038640","10:-1.136220","9:0.671830","8:-0.891410","7:-0.490620","6:-0.183940","5:-0.240750",
"4:-0.848510","3:0.606890","2:-0.325740","1:0.768960", NULL);

  Set_Links(&link_ptr, 26, NULL,
"22:0.391630","21:1.029910","20:-1.095520","19:0.962540","18:-0.771870","17:-0.219650","16:0.606400","15:0.483210","14:-0.065870",
"13:0.980800","12:3.937330","11:-3.999160","10:-0.347120","9:-0.230850","8:-0.000460","7:-1.141310","6:0.172220","5:0.564500",
"4:-0.210400","3:-1.138470","2:0.135260","1:0.058260", NULL);

  Set_Links(&link_ptr, 27, NULL,
"22:-0.767630","21:0.879430","20:0.008030","19:1.028450","18:0.769700","17:0.225150","16:0.424720","15:-0.225120","14:-0.116760",
"13:-0.191840","12:-3.677860","11:-3.188680","10:-0.797020","9:0.210290","8:-0.875800","7:-1.135560","6:0.571540","5:-1.065390",
"4:0.787440","3:0.576900","2:-0.674490","1:-1.217580", NULL);

  Set_Links(&link_ptr, 28, NULL,
"22:0.829240","21:-0.299700","20:-0.429980","19:-0.855030","18:-0.380870","17:-0.644250","16:0.000890","15:-0.465340","14:0.148540",
"13:0.640910","12:-2.967320","11:-0.998200","10:0.928920","9:0.941940","8:0.820910","7:-0.665440","6:0.102100","5:-0.515980",
"4:-0.194000","3:-0.034910","2:-1.237950","1:0.057040", NULL);

  Set_Links(&link_ptr, 29, NULL,
"22:-0.897720","21:-0.066450","20:0.432320","19:0.268910","18:0.911660","17:-0.926920","16:-0.465040","15:0.658690","14:0.780700",
"13:-0.093250","12:-0.799460","11:0.195630","10:-0.782580","9:-0.629560","8:-0.305990","7:-0.909530","6:0.779330","5:0.164580",
"4:-0.689970","3:-1.022060","2:0.547910","1:0.463850", NULL);

  Set_Links(&link_ptr, 30, NULL,
"22:-0.567360","21:0.605130","20:-0.314920","19:-0.249180","18:0.270440","17:-0.308780","16:-0.047910","15:0.309000","14:-0.155950",
"13:-0.122190","12:-3.573590","11:-0.398590","10:-0.471540","9:0.705040","8:0.330600","7:-0.386480","6:-0.210050","5:0.337880",
"4:0.088940","3:0.055460","2:-0.029960","1:0.616070", NULL);

  Set_Links(&link_ptr, 31, NULL,
"22:0.228870","21:-1.124420","20:0.693390","19:-0.112720","18:0.072520","17:-0.269690","16:1.039820","15:-0.625110","14:-0.907860",
"13:-0.284660","12:3.463850","11:2.185230","10:0.376720","9:-0.429910","8:-0.606360","7:0.942720","6:-0.609220","5:1.211700",
"4:-0.725120","3:1.144620","2:0.580680","1:1.010590", NULL);

  Set_Links(&link_ptr, 32, NULL,
"22:-0.471520","21:0.126880","20:-0.537060","19:-0.527320","18:0.573200","17:-0.737540","16:-0.094810","15:0.579350","14:-0.541370",
"13:0.053960","12:1.707210","11:4.283320","10:0.589560","9:0.022120","8:0.760020","7:0.326160","6:0.284210","5:0.210910",
"4:0.266540","3:-0.761580","2:-0.471420","1:-0.422710", NULL);

  Set_Links(&link_ptr, 33, NULL,
"22:-0.540760","21:-0.711820","20:-0.142700","19:-0.666200","18:-0.848000","17:0.531770","16:0.682420","15:-0.092560","14:-0.765910",
"13:-0.470580","12:-0.089460","11:0.501630","10:-0.134130","9:-0.139500","8:-0.845770","7:0.067700","6:-0.665280","5:-0.399220",
"4:0.477710","3:-0.033590","2:-0.412040","1:-0.499780", NULL);

  Set_Links(&link_ptr, 34, NULL,
"22:0.563800","21:-0.167700","20:0.645270","19:-0.483640","18:0.046910","17:0.817350","16:-0.218590","15:1.014730","14:-0.254990",
"13:0.654060","12:1.007580","11:0.030280","10:0.465800","9:0.393520","8:-0.039970","7:0.758920","6:-0.427640","5:-0.747900",
"4:0.039940","3:0.745320","2:0.227020","1:-0.817710", NULL);

  Set_Links(&link_ptr, 35, NULL,
"22:0.163010","21:-0.432130","20:-0.839970","19:0.521190","18:0.257320","17:0.012390","16:0.656650","15:-0.038400","14:-0.797100",
"13:0.603930","12:-2.052930","11:5.918260","10:1.090910","9:-0.172150","8:-1.080180","7:0.639620","6:0.598620","5:0.765520",
"4:-0.921280","3:-1.058030","2:0.506220","1:-0.584720", NULL);

  Set_Links(&link_ptr, 36, NULL,
"22:-0.877130","21:0.008390","20:0.070090","19:-0.398660","18:0.551970","17:-0.051390","16:-0.884260","15:0.117620","14:-0.092210",
"13:-1.192940","12:0.432630","11:0.192530","10:-1.178580","9:-0.833270","8:-1.110690","7:0.357960","6:0.277470","5:0.248740",
"4:0.708210","3:0.177600","2:0.005730","1:0.002090", NULL);

  Set_Links(&link_ptr, 37, NULL,
"22:-0.605910","21:0.223340","20:1.622640","19:-1.373190","18:-0.830160","17:-0.154260","16:0.616280","15:-1.906170","14:-0.448370",
"13:-1.026600","12:1.616350","11:5.834940","10:0.423010","9:-0.127380","8:0.774060","7:0.144590","6:-0.337010","5:1.535850",
"4:0.698530","3:0.714330","2:-0.033270","1:-0.408500", NULL);

  Set_Links(&link_ptr, 38, NULL,
"22:1.073760","21:0.065030","20:-0.734730","19:0.743100","18:0.095650","17:0.648290","16:0.286510","15:-0.791990","14:-0.168240",
"13:-0.412480","12:-0.092270","11:-0.694930","10:0.443820","9:0.175100","8:0.486610","7:0.645970","6:-0.724090","5:-0.476230",
"4:0.172940","3:-0.058960","2:-0.437110","1:-0.648280", NULL);

  Set_Links(&link_ptr, 39, NULL,
"22:0.008950","21:-0.278890","20:0.727360","19:0.166320","18:-0.288470","17:0.757170","16:0.232670","15:-0.079150","14:0.362210",
"13:0.362180","12:4.212840","11:-2.862150","10:-0.861140","9:-0.000690","8:-0.622600","7:-0.837680","6:-0.994340","5:0.292820",
"4:0.841140","3:0.150190","2:0.845220","1:-0.820320", NULL);

  Set_Links(&link_ptr, 40, NULL,
"22:-0.507920","21:-1.008550","20:0.377480","19:0.740790","18:0.728710","17:0.487020","16:0.992100","15:-0.074010","14:0.697480",
"13:-0.269990","12:0.364630","11:0.330020","10:-0.834450","9:-0.806620","8:-0.200790","7:-0.652080","6:-0.408850","5:-0.464270",
"4:0.438740","3:1.140530","2:-0.585690","1:0.968910", NULL);

  Set_Links(&link_ptr, 41, NULL,
"22:-0.508340","21:-0.365570","20:0.174280","19:-0.082360","18:-0.313860","17:-0.902200","16:-0.967610","15:0.679940","14:-0.789960",
"13:-0.885030","12:-0.923350","11:-0.047290","10:-1.137040","9:0.555280","8:0.323640","7:-0.458270","6:-0.501320","5:0.527380",
"4:-0.356320","3:-0.248160","2:0.882810","1:0.666050", NULL);

  Set_Links(&link_ptr, 42, NULL,
"22:0.285430","21:-0.575550","20:-0.162570","19:0.158480","18:-0.597570","17:-0.583860","16:-0.299590","15:0.270140","14:-0.663380",
"13:-0.743180","12:0.121480","11:0.792260","10:-0.285300","9:0.227760","8:-0.028080","7:-0.264650","6:0.465760","5:-0.117000",
"4:-0.231810","3:0.071090","2:0.083430","1:0.121420", NULL);

  Set_Links(&link_ptr, 43, NULL,
"22:-0.158990","21:-0.892730","20:-0.464240","19:0.063400","18:-0.890390","17:0.864420","16:0.618430","15:0.152770","14:-0.956120",
"13:-0.516610","12:0.189640","11:0.508270","10:-0.771340","9:-0.374250","8:-0.831820","7:0.442110","6:0.447950","5:-0.472000",
"4:-0.304420","3:-0.279480","2:-0.401950","1:-0.442240", NULL);

  Set_Links(&link_ptr, 44, NULL,
"22:0.819130","21:-0.184720","20:-0.201500","19:0.311780","18:0.557510","17:-0.072910","16:-0.410660","15:-0.008590","14:-0.241730",
"13:-0.751870","12:-0.110630","11:-0.559590","10:-0.583210","9:0.286020","8:-0.427900","7:-0.213050","6:-0.881060","5:-0.305760",
"4:-0.556120","3:-0.882630","2:0.679430","1:-0.375150", NULL);

  Set_Links(&link_ptr, 45, NULL,
"44:0.403590","43:0.787560","42:-1.040310","41:0.896650","40:0.595300","39:-0.707570","38:-0.851760","37:2.961620","36:0.506280",
"35:2.402680","34:-0.981520","33:-0.688290","32:1.804360","31:0.640760","30:-0.351050","29:-0.456920","28:-0.263090","27:-0.768630",
"26:-1.695870","25:0.811390","24:-0.393230","23:0.567280", NULL);

  Set_Links(&link_ptr, 46, NULL,
"44:0.183270","43:-0.243300","42:-0.563710","41:0.438800","40:0.059900","39:1.011120","38:-0.629070","37:0.768600","36:-0.720570",
"35:-0.845790","34:-0.078760","33:0.560430","32:0.668260","31:1.001470","30:-1.856740","29:0.091100","28:-1.364120","27:-0.920580",
"26:1.768450","25:-0.098620","24:-0.479890","23:-0.498000", NULL);


}

net_error Init_Net()
{
   struct Unit *unit_ptr;
   extern void UPDATE_CPNPropagate();


   AllocMem();


   Init_Units();   
   if(error) return(error);
   Init_Connect(); 
   if(error) return(error);

/* Sorting Network Topologically */

   if(UPDATE_FUNC ==  (FunctionPtr) UPDATE_topologicalPropagate)
      TopoSortT(); //topo_ptr_array);
      else   if(UPDATE_FUNC == (FunctionPtr) UPDATE_CPNPropagate)
	     TopoSortIHO(); //topo_ptr_array);
	     else TopoSortFF(); //topo_ptr_array);


  return(error);

}











/***********************************************************************

		       Setting Functions

************************************************************************/










/* get the unit pointer */

struct Unit *Set_CurrentUnit(int unit_no)
{
  struct Unit *unit_ptr;

  if ((unit_no <= MAX_UNIT_NO)||(unit_no >= MIN_UNIT_NO))
  unit_ptr = unit_array + unit_no;
  else return(NULL);


  return( unit_ptr );

}




void Set_Site(struct SiteTable **site_ptr,char *name,SiteFuncPtr site_func)
{
   (*site_ptr)->site_name = name;
   (*site_ptr)->site_func = site_func;
   (*site_ptr)++;

}





void Set_SiteEntry(struct FtypeUnitStruct *F_ptr,char *site_name)
{
  struct SiteTable *site_entry;
  struct Site *site_ptr;

  site_ptr = (struct Site *) calloc(1, sizeof( struct Site));
  if (site_ptr == NULL) error = ERR_MEMORY;
  site_ptr->next = F_ptr->sites;
  F_ptr->sites = site_ptr;
  site_entry = site_array;

  while(strcmp(site_entry->site_name, site_name)) site_entry++;

  site_ptr->site_table = site_entry;
}





void Set_FuncType(struct FtypeUnitStruct *F_ptr,char *name,ActFuncPtr act_func,OutFuncPtr out_func)
{
   F_ptr->type_name = name;
   F_ptr->act_func = act_func;
   F_ptr->out_func = out_func;
}








/* set the type of the unit */

void Set_UnitTop(struct Unit **unit_ptr,char st)
{
      switch(st)
      {
       case 'i': (*unit_ptr)->flags |= UFLAG_TTYP_IN; break;
       case 'o': (*unit_ptr)->flags |= UFLAG_TTYP_OUT; break;
       case 'h': (*unit_ptr)->flags |= UFLAG_TTYP_HIDD; break;
       case 'd': (*unit_ptr)->flags |= UFLAG_TTYP_DUAL; break;
       case 's': (*unit_ptr)->flags |= UFLAG_TTYP_SPEC; break;
       default : error = ERR_UNIT ;
      }
}



void Set_Unit(int no, ...)
{
   int i,ready;
   va_list argp;
   char *Ftype_name, *name, st, *site;
   float act, bias;
   ActFuncPtr act_func;
   OutFuncPtr out_func;

   struct Unit      *unit_ptr;
   struct FtypeUnitStruct *F_ptr;
   struct SiteTable *site_entry;
   struct Site *site_ptr, *ftype_site;
   bool SIT = FALSE;
   char *str = NULL;


   va_start(argp,no);
//   no = va_arg(argp, int);
   Ftype_name = va_arg(argp, char *);
   name = va_arg(argp, char *);
   act = va_arg(argp, double); bias = va_arg(argp, double);
   st = va_arg(argp, int);
   act_func = va_arg(argp, ActFuncPtr);
   out_func = va_arg(argp, OutFuncPtr);

   unit_ptr = unit_array + no;
   unit_ptr->unit_name = (char *)my_strdup(name);
   unit_ptr->act = act;
   unit_ptr->bias = bias;
   unit_ptr->flags = UFLAG_INITIALIZED;
   Set_UnitTop(&unit_ptr, st);

 /* Ftype entry */

   if(Ftype_name != NULL)
   {
       F_ptr = FTypeEntry;
       while(F_ptr->type_name)  /*search for entry*/
	    {
	    if(strcmp(F_ptr->type_name, Ftype_name) != 0) F_ptr++;
	    else   { unit_ptr->Ftype_entry = F_ptr;
		     if (F_ptr->sites != NULL) SIT = TRUE;
		     break;}
	    }
     if(F_ptr->type_name == NULL) error =  ERR_FTYPE;

     unit_ptr->Ftype_entry = F_ptr;

     unit_ptr->out_func = F_ptr->out_func;
     unit_ptr->act_func = F_ptr->act_func;

   
     if (SIT == TRUE)
       {  /* unit type has sites */

       ftype_site = F_ptr->sites;
       while(ftype_site != NULL)
	 {
	 site_ptr = (struct Site *) calloc(1, sizeof( struct Site));
	 if(site_ptr == NULL) error =  ERR_MEMORY;

	 site_ptr->next = unit_ptr->sites;
	 unit_ptr->sites = site_ptr;
	 site_ptr->site_table = ftype_site->site_table;
	 ftype_site = ftype_site->next;
	 }
       }
    }

   else  /* Default Unit*/
   {
     unit_ptr->Ftype_entry = NULL;
   
     if(act_func == NULL) unit_ptr->act_func = DEF_ACT_FUNC;
     else unit_ptr->act_func = act_func;
     if(out_func == NULL) unit_ptr->out_func = DEF_OUT_FUNC;
     else  unit_ptr->out_func = out_func;

     site = va_arg(argp, char *);
     if(site != NULL) str = (char *) my_strdup(site);

     while(str != NULL)
     {
      SIT = TRUE;
      site_ptr = (struct Site *) calloc(1, sizeof( struct Site));

      site_ptr->next = unit_ptr->sites;
      unit_ptr->sites = site_ptr;
      site_entry = site_array;

      ready = FALSE;

      i=0;

      while (!ready)
        {
        if (NO_OF_SITE_TYPES<i)
          ready = TRUE;
        else
          {
          i++;
          if (strcmp(site_entry->site_name, str))
            site_entry++;
          else
            ready = TRUE;
          }
        }


      site_ptr->site_table = site_entry;


      str = va_arg(argp, char *);
     }


   }

   if(SIT) unit_ptr->flags |= UFLAG_SITES;
   va_end(argp);
}



void Set_Links( struct Link **link, ...)
{
  va_list argp;
//  struct Link **link;
  int no, src_no;
  char *site, *st;
  struct Site *CurrentSite;

  struct Unit *target_ptr, *src_unit_ptr;
  float weight;
  FlagWord flags;


  va_start(argp, link);
//  link = va_arg(argp, struct Link **);
  no = va_arg(argp, int);
  site = va_arg(argp, char *);

  target_ptr = Set_CurrentUnit(no);
  flags = target_ptr->flags & UFLAG_INPUT_PAT;



  if(site && (flags== UFLAG_SITES))
      {
      /* set current site*/

      CurrentSite = target_ptr->sites;
      while((strcmp(CurrentSite->site_table->site_name, site) != 0)&&(CurrentSite !=NULL))
	CurrentSite = CurrentSite->next;

      } else if(target_ptr == NULL) error = ERR_SITE;




   if(flags == UFLAG_SITES)
/* unit has sites */
    CurrentSite->links = *link;
   else
/* unit has direct links*/
     {
     target_ptr->sites = (struct Site *)(*link);
     target_ptr->flags |= UFLAG_DLINKS;
     }


  st = va_arg(argp, char *);

  do
  {
    sscanf(st,"%d:%f", &src_no, &weight);
    src_unit_ptr = Set_CurrentUnit(src_no);


    (*link)->to = src_unit_ptr;
    (*link)->weight = weight;

    (*link)++;

  }while((st = va_arg(argp, char *)) != NULL);

  (*link)++;
  va_end(argp);
}
















/****************************************************************************

				Error Manipulating Function

****************************************************************************/


char err_msg0[] = "\nno error!\n";
char err_msg1[] = "\nsyntax error!\n";
char err_msg2[] = "\ninsufficient memory!\n";
char err_msg3[] = "\nunit error!\n";
char err_msg4[] = "\nfunctionality type name is not defined!\n";
char err_msg5[] = "\nsite name is not defined!\n";
char err_msg6[] = "\ncan't open file!\n";
char err_msg7[] = "\nphysical i/o error\n";
char err_msg8[] = "\nloading/creating pattern error!\n";
char err_msg9[] = "\ntopology sorting error!\n";
char err_msg10[] = "\nfunction name is not defined!\n";
	


char *err_chk(int err)
{
   switch(err)
   {
     case(NO_ERR)       : return err_msg0; break;
     case(ERR_SYNTAX)   : return err_msg1; break;
     case(ERR_MEMORY)   : return err_msg2; break;
     case(ERR_UNIT)     : return err_msg3; break;
     case(ERR_FTYPE)    : return err_msg4; break;
     case(ERR_SITE)     : return err_msg5; break;
     case(ERR_FILE_OPEN): return err_msg6; break;
     case(ERR_IO )      : return err_msg7; break;
     case(ERR_PATTERN)  : return err_msg8; break;
     case(ERR_TOPOMODE) : return err_msg9; break;
     case(ERR_FUNC)     : return err_msg10; break;

   }
}





/***************************************************************************

		       Topological Sorting  Functions

***************************************************************************/




/*  Clears the refresh flag of all units  for sorting
*/
void  clear_flags()
{
  register struct Unit   *unit_ptr;

  FOR_ALL_UNITS( unit_ptr )
      unit_ptr->flags &= ~UFLAG_REFRESH;
}



/*  Depth search routine for topological sorting
*/
void  DepthFirstT(struct Unit   *unit_ptr, int  depth)
{
  struct Site   *site_ptr;
  struct Link   *link_ptr;


  if (unit_ptr->flags & UFLAG_REFRESH)
/*  the flag is set: stop searching */
     return;
  else
    /*  set the 'touch' flag  */
    unit_ptr->flags |= UFLAG_REFRESH;


   switch (unit_ptr->flags & UFLAG_INPUT_PAT)
     {
      case  UFLAG_DLINKS:                         /*  unit has direct links  */
      FOR_ALL_LINKS( unit_ptr, link_ptr )
	DepthFirstT( link_ptr->to, depth + 1);   /*  increase depth  */

      break;

      case  UFLAG_SITES:                           /*  unit has sites  */
	FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
	  DepthFirstT( link_ptr->to, depth + 1);  /*  increase depth  */

      break;
  }

/*  store sorted unit pointer  */

  *topo_ptr++ = unit_ptr;
}






/*  Sort units topological (general version) and stores the
    pointers to this units in the topologic array.

    Update Functions: Topological_Order

NOTE:
    Units are not sorted by their topologic type (that's not possible in
    general case).
*/



void TopoSortT()
{
  register struct Unit   *unit_ptr;

  clear_flags(); /* reset units 'touch' flags */
  topo_ptr = topo_ptr_array;  /*  initialize global pointer */

  /*  limit left side of the topological array with NULL pointer  */
  *topo_ptr++ = NULL;

  /*  begin depth search at the first output unit  */

  FOR_ALL_UNITS( unit_ptr )
    if  (unit_ptr->flags & UFLAG_TTYP_OUT)
      DepthFirstT( unit_ptr, 1 );  /*  sort the units topological (using depth search
				       algorithm, starting at this output unit */

  /*  limit right side of the topologic array with NULL pointer  */
  *topo_ptr++ = NULL;


}




/*  Depth search routine for topological sorting in feedforward networks
*/
void DepthFirstFF(struct Unit   *unit_ptr,int  depth)
{
  struct Site   *site_ptr;
  struct Link   *link_ptr;



  if (unit_ptr->flags & UFLAG_REFRESH)
       /*  the 'touch' flag is set: don't continue search */
       return;
  else                                            /* set the 'touch' flag  */
    unit_ptr->flags |= UFLAG_REFRESH;

  switch (unit_ptr->flags & UFLAG_INPUT_PAT)
    {
    case  UFLAG_DLINKS:                           /*  unit has direct links  */
      FOR_ALL_LINKS( unit_ptr, link_ptr )
	DepthFirstFF( link_ptr->to, depth + 1);  /*  increase depth  */

      break;

    case  UFLAG_SITES:                            /*  unit has sites  */
      FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
	DepthFirstFF( link_ptr->to, depth + 1 );  /*  increase depth  */

      break;
  }


						  /*  store only hidden units  */
  if (unit_ptr->flags & UFLAG_TTYP_HIDD)
  *topo_ptr++ = unit_ptr;                  /* store sorted unit pointer  */
}








/*  Sorts unit topological in feed-forward networks and stores the
    pointers to this units in the topologic array in the following order:
     - input,
     - hidden and
     - output units

    This general sorting function make following assumptions
    for feed-forward networks:
     a) input units don't have input connections to other units and
     b) output units don't have outputs connections to other units.
     c) no dead units
     d) no cycles
*/

void TopoSortFF()
{
  register struct Unit   *unit_ptr;


  clear_flags();                                     /* reset units 'touch' flags  */
  topo_ptr = topo_ptr_array;                  /*  initialize global pointer */

  /*  limit left side of the topological array with NULL pointer  */
  *topo_ptr++ = NULL;

  /*  put all input units in the topologic array  */

  FOR_ALL_UNITS( unit_ptr )
    if (unit_ptr->flags & UFLAG_TTYP_IN)
     {
      if ((unit_ptr->flags & UFLAG_INPUT_PAT) != UFLAG_NO_INP)
	  error =  ERR_TOPOMODE;

      *topo_ptr++ = unit_ptr;                  /*  save input unit pointers */
     }


  /*  limit input units in the topological array with NULL pointer  */
  *topo_ptr++ = NULL;

  /*  begin depth search at the first output unit  */
  FOR_ALL_UNITS( unit_ptr )
    if (unit_ptr->flags & UFLAG_TTYP_OUT)
      DepthFirstFF( unit_ptr, 1 );  /*  sort the units topological (using depth search
				       algorithm, starting at this output unit */


  /*  limit hidden units in the topological array with NULL pointer  */
  *topo_ptr++ = NULL;

  /*  put all output units in the topological array  */
  FOR_ALL_UNITS( unit_ptr )
    if  (unit_ptr->flags & UFLAG_TTYP_OUT)
      *topo_ptr++ = unit_ptr;                    /*  save output unit  */

  /*  limit right side of the topologic array with NULL pointer  */
  *topo_ptr++ = NULL;


}




/*
    Sort units by their topologic type, i.e. Input, Hidden, Output units and
    stores the pointers to this units in the topologic array.

    Update Function: CPN_Order
*/

void TopoSortIHO()
{
  TopoPtrArray     topo_ptr;
  register struct Unit   *unit_ptr;



  topo_ptr = topo_ptr_array;

  /*  limit left side of the topological array with NULL pointer  */
  *topo_ptr++ = NULL;

  /*  get input units  */
  FOR_ALL_UNITS( unit_ptr )
    if  (unit_ptr->flags & UFLAG_TTYP_IN)
      *topo_ptr++ = unit_ptr;


  /*  limit input units in the topological array with NULL pointer  */
  *topo_ptr++ = NULL;

  /*  get hidden units  */
  FOR_ALL_UNITS( unit_ptr )
    if (unit_ptr->flags & UFLAG_TTYP_HIDD)
      *topo_ptr++ = unit_ptr;


  /*  limit hidden units in the topological array with NULL pointer  */
  *topo_ptr++ = NULL;

  /*  get output units  */
  FOR_ALL_UNITS( unit_ptr )
    if (unit_ptr->flags & UFLAG_TTYP_OUT)
      *topo_ptr++ = unit_ptr;

  /*  limit right side of the topologic array with NULL pointer  */
  *topo_ptr++ = NULL;


}















/****************************************************************************

		     Patterns Loading Functions

****************************************************************************/

bool    NextInput(FILE *stream)
{
  register int   c;



  while (TRUE)
  {
    do c = getc( stream ); while ( isspace( c ) );
   if (c != '#')  break;
    do  c = getc( stream ); while (c != EOF && c != '\n');
  }

  if (c == EOF)  return( FALSE );

  ungetc( c, stream );
  return( TRUE );
}



/* create header informations for the network outputs */

void create_PatOutHeader(FILE *pat_in)
{
    int     ret,no_of_input_units,
	    no_of_output_units;

    char    Header1 [125 ];





/*  read header and version number  */
  if ( (ret = fscanf( pat_in, patHeader[0], Header1 )) == 1)
    {  /* new pattern file format  */

/*  read date  */
    if ( (ret = fscanf( pat_in, patHeader[1] )) != 0)
	error =  ERR_SYNTAX;

	 if ( fgets( Header1, 125 , pat_in  ) == NULL)
	    error =  ERR_SYNTAX;       /*  Incompatible file format  */



	 if (!NextInput(pat_in))
	     error =  ERR_SYNTAX; /*  Unexpected EOF  */

/*  read no. of patterns  */
    if ( (ret = fscanf( pat_in, patHeader[2], &no_of_patterns )) != 1)
	 error =  ERR_SYNTAX; /*  Incompatible file format        */


/*  read no. of input units  */
    if ( (ret = fscanf( pat_in, patHeader[3], &no_of_input_units )) != 1)
	error =  ERR_SYNTAX; /*  Incompatible file format        */

/*  read no. of output units  */
    if ( (ret = fscanf( pat_in, patHeader[4], &no_of_output_units )) != 1)
	error =  ERR_SYNTAX;  /*  Incompatible file format        */
    }
  else
    {  /*  old pattern format */
    ret = fscanf( pat_in, "%d%d%d", no_of_patterns, &no_of_input_units,
				     &no_of_output_units );
    if (ret != 3)  error =  ERR_SYNTAX; /*  Incompatible file format        */
    }

  if (no_of_input_units != NO_OF_IN_UNITS )
      /*  Pattern file contains not the same no. of input units as the network  */
	 error =  ERR_PATTERN;

  if (no_of_output_units != NO_OF_OUT_UNITS )
      /*  Pattern file contains not the same no. of output units as the network  */
    error =  ERR_PATTERN;
}



/* load patterns file  */

net_error Load_Pattern_File(FILE * pat_file,Patterns * in_patterns,Patterns * out_patterns )
{
   char ans;
   int       ret, i,  j;
   Patterns  in_pat;
   float     dummy;
   FILE      *pat_in;




   pat_in = pat_file;
   if (pat_in == NULL)
    return(ERR_FILE_OPEN);

  if (!NextInput(pat_in)) return(ERR_SYNTAX);


  create_PatOutHeader(pat_in); //, no_of_patterns);

/* memory allocation for input and output patterns*/

   *in_patterns = (FlintType *)calloc( NO_OF_IN_UNITS * (no_of_patterns), sizeof(float));
     if(*in_patterns == NULL)
       return(ERR_MEMORY); /* mem alloc failed    */

   *out_patterns = (FlintType *)calloc(NO_OF_OUT_UNITS * (no_of_patterns),sizeof(float));
   if (*out_patterns == NULL)
       return(ERR_MEMORY);   /* mem alloc failed    */



  in_pat = *in_patterns;

  for (i = 0; i < no_of_patterns; i++)
    {
    if (!NextInput(pat_in))
       return(ERR_SYNTAX); /*  Unexpected EOF  */

    for (j = 0; j < NO_OF_IN_UNITS; j++)
      {
      ret = fscanf( pat_in, "%f", in_pat );
      if (ret != 1)
	  return(ERR_SYNTAX);    /*  Incompatible file format  */
      in_pat++;
      }

    if (!NextInput(pat_in))
       return(ERR_SYNTAX);      /*  Unexpected EOF  */

    for (j = 0; j < NO_OF_OUT_UNITS; j++)
      {
      if (!NextInput(pat_in))
	  return(ERR_SYNTAX);   /*  Unexpected EOF  */

      ret = fscanf( pat_in, "%f", &dummy );
      if (ret != 1)  return(ERR_SYNTAX);   /*  Incompatible file format  */
      }

    }

  fclose(pat_in);
  return(error);
}







/***************************************************************************

			Propagate and Update Functions

***************************************************************************/




/*
    load input pattern into input units activations
*/

void  Show_Pattern(int pattern_no,Patterns in_patterns)
{
  register struct Unit   *unit_ptr;
  register int   i;
  Patterns  in_pat;


  /*  calc. startaddress of pattern arrays  */
  in_pat = in_patterns + (pattern_no - 1) * NO_OF_IN_UNITS;

   FOR_ALL_UNITS( unit_ptr )
	if  (unit_ptr->flags & UFLAG_TTYP_IN)
	unit_ptr->act = *in_pat++;

}



/*
    Propagate the Pattern File:
    The network is feedforward in topological mode
    with no cycles and no dead units.

*/

net_error Propagate_Pattern_Array(Patterns in_patterns,Patterns out_patterns)
{

  struct Unit   *unit_ptr;
  Patterns       out_pat;
  int pat_no;

  for(pat_no = 1; pat_no <= no_of_patterns; pat_no++)
  {

  Show_Pattern( pat_no, in_patterns);
  (*UPDATE_FUNC)();

   /*  calc. start address of pattern entries  */
  out_pat = out_patterns + (pat_no - 1) * NO_OF_OUT_UNITS;

  /*  store current activation value of output units in pattern array  */

  FOR_ALL_UNITS( unit_ptr )
	if (unit_ptr->flags & UFLAG_TTYP_OUT)
	  *out_pat++ = unit_ptr->act;
  }
  return(error);
}



/*
    Propagate one Pattern:
    The network is feedforward in topological mode
    with no cycles and no dead units.

*/

net_error Propagate_Pattern(float *in_pattern,float *out_pattern)
{
  struct Unit   *unit_ptr;

  Show_Pattern( 1 , in_pattern);
  (*UPDATE_FUNC)();


  /*  store current activation value of output units in pattern array  */

  FOR_ALL_UNITS( unit_ptr )
	if (unit_ptr->flags & UFLAG_TTYP_OUT)
	  *out_pattern++= unit_ptr->act;

  return(error);
}






/***************************************************************************

			 Save  Result Patterns in  File

***************************************************************************/



/*  cut all trailing '0' of the outputs
*/
void cutTrailingZeros(char *string)
{
    int j;

    if (*string == EOS)  return;
    for (j = strlen( string ) - 1; ((string[j] == '0') && (j > 0)); j--) {}

    if (string[j] == '.')
      string[j] = EOS;
    else
      string[j + 1] = EOS;
}


net_error Open_Out_File(FILE **pat_res,FILE* filehandle, \
int start_pattern, float *in_patterns)
{

  time_t      clock;

  *pat_res = filehandle;
  if (*pat_res == NULL)  error =  ERR_FILE_OPEN;
  append = TRUE;

  if(fprintf( *pat_res,"%s %s %s\n", patHeader[5], NET_NAME, NET_FILE_VERSION)==EOF)
     return(ERR_IO);

/*write date*/
  (void) time( &clock);

  if(fprintf( *pat_res,"%s %s\n\n", patHeader[1], ctime( &clock) )==EOF)
    return(ERR_IO);

/* write no. of patterns, input units, output units */

  if(fprintf( *pat_res, "%s%d\n",patHeader[7], no_of_patterns)==EOF)
    return(ERR_IO);

  if(fprintf( *pat_res, "%s%d\n%s%d\n",patHeader[8], NO_OF_IN_UNITS, patHeader[9],
      NO_OF_OUT_UNITS)==EOF)
    return(ERR_IO);

  if(fprintf( *pat_res, "%s%d\n",patHeader[6], start_pattern)==EOF)
    return(ERR_IO);

  if(in_patterns != NULL)
  { if(fprintf(*pat_res, "%s\n", patHeader[10])==EOF) return(ERR_IO);}
  else if(fprintf(*pat_res, "%s\n", patHeader[11])==EOF) return(ERR_IO);
 
  return(NO_ERR);
}



/* write  input and or output patterns */

net_error  Write_Pattern_Arrays(FILE *filehandle, int start_pattern, \
Patterns in_patterns,Patterns out_patterns)
{
  char      work_str[ 250 ];
  int       i,  j, no_pat = 0;
  Patterns  in_pat,  out_pat;
  FILE      *pat_res;


  if( i = Open_Out_File(&pat_res, filehandle, 
          start_pattern, in_patterns))  return(i);

  in_pat = in_patterns + ((start_pattern-1) * NO_OF_IN_UNITS);
  out_pat = out_patterns + ((start_pattern-1) * NO_OF_OUT_UNITS);

  for (i = start_pattern; i <= no_of_patterns; i++)
    {
    if(fprintf( pat_res, "\n#%d", i )==EOF)
    return(ERR_IO);

    if(in_patterns != NULL)
    {
    fputs( "\n", pat_res );
    for (j = 1; j <= NO_OF_IN_UNITS; j++)
      {
      sprintf( work_str, "%.5f", *in_pat );
      cutTrailingZeros( work_str );

      if (j < NO_OF_IN_UNITS)
	if (j % 10 == 0)  strcat( work_str, "\n" );
	else  strcat( work_str, " " );

      if (fputs( work_str, pat_res ) == EOF)
      return(ERR_IO);

      in_pat++;
      }
    }

   fputs( "\n", pat_res );

    if(out_patterns != NULL)
    for (j = 1; j <= NO_OF_OUT_UNITS; j++)
      {
      sprintf( work_str, "%.5f", *out_pat );
      cutTrailingZeros( work_str );

      if (j < NO_OF_OUT_UNITS)
	if (j % 10 == 0)  strcat( work_str, "\n" );
	else  strcat( work_str, " " );

      if (fputs( work_str, pat_res ) == EOF)
        return(ERR_IO);

      out_pat++;
      }
    fputs( "\n", pat_res );
    }

   fclose(pat_res);
   return(error);
}



/* write one input and or one output pattern */

net_error  Write_Pattern(FILE *filehandle,float* in_pattern,float* out_pattern)
{
  char      work_str[ 250 ];
  int       i,  j;
  FILE      *pat_res;

  pat_res = filehandle;
  if (pat_res == NULL)  return(ERR_FILE_OPEN);
  
  if(fprintf(pat_res,"%s %s %s\n", patHeader[5], NET_NAME, NET_FILE_VERSION)==EOF)
     return(ERR_IO);




  if(fprintf( pat_res, "\n#%d", no_of_patterns + 1 )==EOF)
  return(ERR_IO);

  if(in_pattern != NULL)
  {
  fputs( "\n", pat_res );

    for (j = 0; j < NO_OF_IN_UNITS; j++)
      {
      sprintf( work_str, "%.5f", in_pattern[j] );
      cutTrailingZeros( work_str );

      if (j < NO_OF_IN_UNITS -1 )
	if ((j+1) % 10 == 0)  strcat( work_str, "\n" );
	else  strcat( work_str, " " );

      if (fputs( work_str, pat_res ) == EOF)
      return(ERR_IO);

      }
  }

  fputs( "\n", pat_res );

    if(out_pattern != NULL)
    for (j = 0; j < NO_OF_OUT_UNITS; j++)
      {
      sprintf( work_str, "%.5f", out_pattern[j] );
      cutTrailingZeros( work_str );

      if ((j+1) < NO_OF_OUT_UNITS - 1)
	if (j % 10 == 0)  strcat( work_str, "\n" );
	else  strcat( work_str, " " );

      if (fputs( work_str, pat_res ) == EOF)
       return(ERR_IO);

      }
  fputs( "\n", pat_res );


   fclose(pat_res);
   return(error);
}




/****************************************************************************

		   Network Memory Allocation

*****************************************************************************/

net_error AllocMem()
{


   site_array = (STableArray) calloc(NO_OF_SITE_TYPES + 1, sizeof(struct SiteTable));
   if(site_array == NULL) return( ERR_MEMORY );

   FTypeEntry = (FtypeArray ) calloc(NO_OF_UNIT_TYPES + 1 , sizeof(struct FtypeUnitStruct));
   if(FTypeEntry == NULL)     return(  ERR_IO);


   unit_array = (UnitArray) calloc(MAX_UNIT_NO + 1, sizeof(struct Unit));
   if(unit_array == NULL)     return( ERR_IO);

   link_array= (LinkArray)calloc(NO_OF_LINKS + NO_OF_LINK_ENTRIES, sizeof( struct Link));
   if(link_array == NULL)     return(ERR_IO);

   topo_ptr_array = (TopoPtrArray )calloc (NO_OF_UNITS, sizeof(struct Unit));
   if(topo_ptr_array == NULL) return( ERR_MEMORY );

  return(NO_ERR);

}






/*#################################################

     Unit Output Functions

#################################################*/




/*  Linear Output Function
    This function isn't used now, because the identity output function is
    the NULL pointer.
*/
FlintType  OUT_Identity(register FlintType activation )
{
  return( activation );
}


/*  Clipping [0,1] function
*/
FlintType  OUT_Clip_01(register FlintType activation )
{
  if (activation < 0.0)  return( (FlintType) 0.0 );
  if (activation > 1.0)  return( (FlintType) 1.0 );
  return( activation );
}


/*  Clipping [-1,1] function
*/
FlintType  OUT_Clip_11(register FlintType activation )
{
  if (activation < -1.0)  return( (FlintType) -1.0 );
  if (activation > 1.0)  return( (FlintType) 1.0 );
  return( activation );
}

/*  Threshold 0.5 Output Function
*/
FlintType  OUT_Threshold05(register FlintType activation )
{
  if (activation < 0.5)  return( (FlintType) 0.0 );
  return( (FlintType) 1.0 );
}




/*#################################################

     Unit Activation Functions

#################################################*/




/*  Linear Activation Function
*/
FlintType   ACT_Linear(UNIT_PTR unit_ptr )
{
  ACT_FUNC_DEFS
  register FlintType  sum;


  sum =  0.0;
  if (GET_FIRST_UNIT_LINK( unit_ptr ))
    do
      sum += GET_WEIGHTED_OUTPUT;
    while (GET_NEXT_LINK);
  else
    if (GET_FIRST_SITE( unit_ptr ))
      do
	sum += GET_SITE_VALUE;
      while (GET_NEXT_SITE);

  return( sum );
}

/*  Brain-State-in-a-Box Function
*/
FlintType   ACT_BSBFunction(UNIT_PTR unit_ptr )
{
  ACT_FUNC_DEFS
  register FlintType  sum;


  sum =  0.0;
  if (GET_FIRST_UNIT_LINK( unit_ptr ))
    do
      sum += GET_WEIGHTED_OUTPUT;
    while (GET_NEXT_LINK);
  else
    if (GET_FIRST_SITE( unit_ptr ))
      do
	sum += GET_SITE_VALUE;
      while (GET_NEXT_SITE);

  return( sum * GET_UNIT_BIAS( unit_ptr ));
}



/*  Minimum Function (Unit's output and weight)
*/

FlintType   ACT_MinOutPlusWeight(UNIT_PTR unit_ptr )
{
  ACT_FUNC_DEFS
  register FlintType  min1, min2;


  min1 = 0.0;

  if (GET_FIRST_UNIT_LINK( unit_ptr ))
    {
    min1 = GET_OUTPUT + GET_WEIGHT;
    while (GET_NEXT_LINK)
      if ((min2 = GET_OUTPUT + GET_WEIGHT) < min1)
	min1 = min2;
    }
  else
    if (GET_FIRST_SITE( unit_ptr ))
      {
      min1 = GET_SITE_VALUE;
      while (GET_NEXT_SITE)
       if ((min2 = GET_SITE_VALUE) < min1)
	    min1 = min2;
      }

  return( min1 );
}


/*  Hyperbolic Tangent Function
*/
FlintType   ACT_TanHFunction(UNIT_PTR unit_ptr )
{
  ACT_FUNC_DEFS
  register FlintType  sum;


  sum =  0.0;
  if (GET_FIRST_UNIT_LINK( unit_ptr ))
    do
      sum += GET_WEIGHTED_OUTPUT;
    while (GET_NEXT_LINK);
  else
    if (GET_FIRST_SITE( unit_ptr ))
      do
	sum += GET_SITE_VALUE;
      while (GET_NEXT_SITE);

  return( tanh(sum + GET_UNIT_BIAS( unit_ptr )));
}



/*  Sigmoid Function
*/
FlintType   ACT_Logistic(UNIT_PTR unit_ptr )
{
  ACT_FUNC_DEFS
  register FlintType  sum;


  sum =  0.0;
  if (GET_FIRST_UNIT_LINK( unit_ptr ))
    do
      sum += GET_WEIGHTED_OUTPUT;
    while (GET_NEXT_LINK);
  else
    if (GET_FIRST_SITE( unit_ptr ))
      do
	sum += GET_SITE_VALUE;
      while (GET_NEXT_SITE);

  return( (FlintType) (1.0 / (1.0 + exp( -sum - GET_UNIT_BIAS( unit_ptr )))) );
}




/*  Perceptron Function
*/
FlintType   ACT_Perceptron(UNIT_PTR unit_ptr )
{
  ACT_FUNC_DEFS
  register FlintType  sum;


  sum =  0.0;
  if (GET_FIRST_UNIT_LINK( unit_ptr ))
    do
      sum += GET_WEIGHTED_OUTPUT;
    while (GET_NEXT_LINK);
  else
    if (GET_FIRST_SITE( unit_ptr ))
      do
	sum += GET_SITE_VALUE;
      while (GET_NEXT_SITE);

  if (sum > 0.0)
    return( sum );

  return( (FlintType) 0.0 );
}

/*  Signum Function
*/
FlintType   ACT_Signum(UNIT_PTR unit_ptr )
{
  ACT_FUNC_DEFS
  register FlintType  sum;


  sum =  0.0;
  if (GET_FIRST_UNIT_LINK( unit_ptr ))
    do
      sum += GET_WEIGHTED_OUTPUT;
    while (GET_NEXT_LINK);
  else
    if (GET_FIRST_SITE( unit_ptr ))
      do
	sum += GET_SITE_VALUE;
      while (GET_NEXT_SITE);

  if (sum > 0.0)
    return( (FlintType) 1.0 );

  return( (FlintType) -1.0 );
}


/*  Signum0 Function
*/
FlintType   ACT_Signum0(UNIT_PTR unit_ptr )
{
  ACT_FUNC_DEFS
  register FlintType  sum;


  sum =  0.0;
  if (GET_FIRST_UNIT_LINK( unit_ptr ))
    do
      sum += GET_WEIGHTED_OUTPUT;
    while (GET_NEXT_LINK);
  else
    if (GET_FIRST_SITE( unit_ptr ))
      do
	sum += GET_SITE_VALUE;
      while (GET_NEXT_SITE);

  if (sum > 0.0)  return( (FlintType) 1.0 );
  if (sum < 0.0)  return( (FlintType) -1.0 );
  return( (FlintType) 0.0 );
}


/*  Step Function
*/
FlintType   ACT_StepFunction(UNIT_PTR unit_ptr )
{
  ACT_FUNC_DEFS
  register FlintType  sum;


  sum =  0.0;
  if (GET_FIRST_UNIT_LINK( unit_ptr ))
    do
      sum += GET_WEIGHTED_OUTPUT;
    while (GET_NEXT_LINK);
  else
    if (GET_FIRST_SITE( unit_ptr ))
      do
	sum += GET_SITE_VALUE;
      while (GET_NEXT_SITE);

  if (sum > 0.0)  return( (FlintType) 1.0 );
  return( (FlintType) 0.0 );
}


/*  Bi-Directional Associative Memory
*/
FlintType   ACT_BAMFunction(UNIT_PTR unit_ptr )
{
  ACT_FUNC_DEFS
  register FlintType  sum;


  sum =  0.0;
  if (GET_FIRST_UNIT_LINK( unit_ptr ))
    do
      sum += GET_WEIGHTED_OUTPUT;
    while (GET_NEXT_LINK);
  else
    if (GET_FIRST_SITE( unit_ptr ))
      do
	sum += GET_SITE_VALUE;
      while (GET_NEXT_SITE);

  if (sum > 0.0)  return( (FlintType) 1.0 );
  if (sum < 0.0)  return( (FlintType) -1.0 );
  return( GET_UNIT_ACT( unit_ptr ) );
}


/*  demonstation function: this function act like the Logistic function,
    but the site with the name "Inhibit" will skipped.
*/
FlintType   ACT_LogisticI(UNIT_PTR unit_ptr )
{
  ACT_FUNC_DEFS
  register FlintType  sum;


  sum = 0.0;
  if (GET_FIRST_SITE( unit_ptr ))
    /*  Do not calculate the 'Inhibit' site */
    do
      if (strcmp( "Inhibit", GET_SITE_NAME ))
	sum += GET_SITE_VALUE;
    while (GET_NEXT_SITE);
  else
    if (GET_FIRST_UNIT_LINK( unit_ptr ))
      do
	sum += GET_WEIGHTED_OUTPUT;
      while (GET_NEXT_LINK);

  return( (FlintType) (1.0 / (1.0 + exp( -sum - GET_UNIT_BIAS( unit_ptr )))) );
}

/* help function for all Radial Basis Activation, Derivation and Learn
 * functions. Computes the square of the L2-Norm of (T - X), where T is the
 * vector of all weights from links leading to <unit_ptr> and X is the
 * vector of output units the links are connected from.
 * Store calculated value into value_a field of the current unit.
 * ALL FUTURE RBF ACTIVATION FUNCTIONS HAVE TO CALL THIS FUNCTION !!!!!!!!!!
 */


FlintType RbfUnitGetNormsqr(UNIT_PTR unit_ptr)
{
        ACT_FUNC_DEFS
        register FlintType      norm_2 = 0.0;   /* |X - T|^2            */
        register FlintType      diff;           /* difference           */


        if (!GET_FIRST_UNIT_LINK(unit_ptr))
        {
                printf("No input links!\n");
                return norm_2;
        }

        do
        {
                diff = GET_OUTPUT - GET_WEIGHT;
                norm_2 += diff * diff;
        }
        while (GET_NEXT_LINK);

 /*  general purpose elements for the  learning functions
 
      return unit_ptr -> value_a = norm_2;  */
}


/*
 * Gaussian RBF Activation function: h(L2, s) = exp(-s*L2^2)
 * where L2 is the L2 Norm (see RbfUnitGetNormsqr), and s is the bias 
 * of <unit_ptr>.
 */

FlintType   ACT_RBF_Gaussian(UNIT_PTR unit_ptr )
{
        register FlintType      norm_2;

        norm_2 = RbfUnitGetNormsqr(unit_ptr);
        return (FlintType) exp(- GET_UNIT_BIAS(unit_ptr)*norm_2);
}

/*
 * Multiquadratic Activation function: h(L2, s) = sqrt(s^2 + L2^2)
 */

FlintType ACT_RBF_Multiquadratic( UNIT_PTR unit_ptr )
{
      register FlintType      norm_2;

      norm_2 = RbfUnitGetNormsqr(unit_ptr);
      return (FlintType) sqrt(norm_2 + GET_UNIT_BIAS(unit_ptr));
}


/*
 * Thin plate splines Activation function: h(L2, s) = (L2*s)^2*ln(L2*s)
 */



FlintType ACT_RBF_Thinplatespline(UNIT_PTR unit_ptr )
{
      register FlintType      norm_2;
      register FlintType      bias;

      norm_2 = RbfUnitGetNormsqr(unit_ptr);
      bias = GET_UNIT_BIAS(unit_ptr);

      if (norm_2 == (FlintType) 0.0)
          return (FlintType) 0.0;
      else
          return (FlintType) bias*bias*norm_2*(0.5*log(norm_2) + log(bias));
}


/*  Linear Activation Function + BIAS
*/
FlintType   ACT_Linear_bias(UNIT_PTR unit_ptr )
{
  ACT_FUNC_DEFS
  register FlintType  sum;


  sum =  0.0;
  if (GET_FIRST_UNIT_LINK( unit_ptr ))
    do
      sum += GET_WEIGHTED_OUTPUT;
    while (GET_NEXT_LINK);
  else
    if (GET_FIRST_SITE( unit_ptr ))
      do
      sum += GET_SITE_VALUE;
      while (GET_NEXT_SITE);

  return( sum + GET_UNIT_BIAS(unit_ptr));
}

/*#################################################

       Site functions

#################################################*/




/*  Linear Site Function
*/
FlintType  SITE_WeightedSum( SITE_PTR site_ptr )
{
  SITE_FUNC_DEFS
  register FlintType  sum;


  sum = 0.0;
  if (GET_FIRST_SITE_LINK( site_ptr ))
    do
      sum += GET_WEIGHTED_OUTPUT;
    while (GET_NEXT_LINK);

  return( sum );
}


/*  Product of all predecessor outputs and input link weights
*/
FlintType  SITE_Product( SITE_PTR site_ptr )
{
  SITE_FUNC_DEFS
  register FlintType  prod;


  if (GET_FIRST_SITE_LINK( site_ptr ))
    {
    prod = 1.0;
    do
      prod *= GET_WEIGHTED_OUTPUT;
    while (GET_NEXT_LINK);

    return( prod );
    }
  else
    return( (FlintType) 0.0 );
}


/*  Like SITE_Product() but no weighting of the unit's output
*/
FlintType  SITE_ProductA(SITE_PTR site_ptr )
{
  SITE_FUNC_DEFS
  register FlintType  prod;


  if (GET_FIRST_SITE_LINK( site_ptr ))
    {
    prod = 1.0;
    do
      prod *= GET_OUTPUT;
    while (GET_NEXT_LINK);

/*  Future Application (in SNNS-Kernel V1.4 the sites don't have weights).
    So the return value is only the product.
*/
    return( GET_SITE_WEIGHT * prod );
    }
  else
    return( (FlintType) 0.0 );
}



/*  Get the highest weighted output
*/
FlintType  SITE_Max(SITE_PTR site_ptr )
{
  SITE_FUNC_DEFS
  register FlintType  max, out;


  if (GET_FIRST_SITE_LINK( site_ptr ))
    {
    max = GET_WEIGHTED_OUTPUT;

    while (GET_NEXT_LINK)
      {
      out = GET_WEIGHTED_OUTPUT;
      if (max < out)  max = out;
      }

    return( max );
    }
  else
    return( (FlintType) 0.0 );
}


/*  Get the lowest weighted output
*/
FlintType  SITE_Min(SITE_PTR site_ptr )
{
  SITE_FUNC_DEFS
  register FlintType  min, out;


  if (GET_FIRST_SITE_LINK( site_ptr ))
    {
    min = GET_WEIGHTED_OUTPUT;

    while (GET_NEXT_LINK)
      {
      out = GET_WEIGHTED_OUTPUT;
      if (min > out)  min = out;
      }

    return( min );
    }
  else
    return( (FlintType) 0.0 );
}






/*#################################################

       Update  functions

#################################################*/


/*  synchronous propagation
*/
void  UPDATE_syncPropagate()
{
  register struct Unit   *unit_ptr;


  /*    update unit activations first
  */
  FOR_ALL_UNITS( unit_ptr )
    if (!(unit_ptr->flags & UFLAG_TTYP_IN))
      /*  unit isn't an input unit and is in use and enabled  */
      unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);

  /*    update unit outputs
  */
  FOR_ALL_UNITS( unit_ptr )
      if (unit_ptr->out_func == OUT_IDENTITY)
	/*  identity output function: there is no need to call the output function  */
	unit_ptr->output = unit_ptr->act;
      else
	/*  no identity output function: calculate unit's output also  */
	unit_ptr->output = (*unit_ptr->out_func) (unit_ptr->act);
}


void  UPDATE_topologicalPropagate()
{
  register struct Unit   *unit_ptr;
  register TopoPtrArray     topo_ptr;
  int  ret_code;



  topo_ptr = topo_ptr_array;

  /*  topological propagation  */
  while ((unit_ptr = *++topo_ptr) != NULL)
    {
    if (!(unit_ptr->flags & UFLAG_TTYP_IN))
      /*  this isn't a input unit: calculate the activation of the unit by
	  calling the activation function
      */
      unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);

    if (unit_ptr->out_func == OUT_IDENTITY)
      /*  identity output function: there is no need to call the output function  */
      unit_ptr->output = unit_ptr->act;
    else
      /*  no identity output function: calculate unit's output also  */
      unit_ptr->output = (*unit_ptr->out_func) (unit_ptr->act);
  }

}




/*  serial propagation
*/
void  UPDATE_serialPropagate()
{
  register struct Unit   *unit_ptr;


  /*    update unit activations and outputs
  */
  FOR_ALL_UNITS( unit_ptr )
   {
      if (!(unit_ptr->flags & UFLAG_TTYP_IN))
	/*  this isn't a input unit: calculate the activation of the unit by
	    calling the activation function
	*/
	unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);

      if (unit_ptr->out_func == OUT_IDENTITY)
	/*  identity output function: there is no need to call the output function  */
	unit_ptr->output = unit_ptr->act;
      else
	/*  no identity output function: calculate unit's output also  */
	unit_ptr->output = (*unit_ptr->out_func) (unit_ptr->act);
   }
}




/*  random order propagation
*/

double  drand48();
long    lrand48();
void    srand48();

void UPDATE_randomOrderPropagate()
{
  register struct Unit   *unit_ptr, *u_array;
  register int   no_of_units;
  int   n;


  u_array = unit_array;
  no_of_units = NO_OF_UNITS;

  for (n = 0; n < no_of_units; n++)
    {
    /*    choose unit  */
    unit_ptr = u_array + (1 + rand() % no_of_units);

    if (!(unit_ptr->flags & UFLAG_TTYP_IN))
      /*  this isn't a input unit: calculate the activation of the unit by
	  calling the activation function
      */
      unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);

    if (unit_ptr->out_func == OUT_IDENTITY)
      /*  identity output function: there is no need to call the output function  */
      unit_ptr->output = unit_ptr->act;
    else
      /*  no identity output function: calculate unit's output also  */
      unit_ptr->output = (*unit_ptr->out_func) (unit_ptr->act);
  }

}



/*  random permutation propagation
*/
void  UPDATE_randomPermutPropagate()
{
  register struct Unit   *unit_ptr;
  register TopoPtrArray  topo_ptr;
  int  ret_code;



  topo_ptr = topo_ptr_array;

  /*  propagate net  */
  while ((unit_ptr = *++topo_ptr) != NULL)
    {
    if (!(unit_ptr->flags & UFLAG_TTYP_IN))
      /*  this isn't a input unit: calculate the activation of the unit by
	  calling the activation function
      */
      unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);

    if (unit_ptr->out_func == OUT_IDENTITY)
      /*  identity output function: there is no need to call the output function  */
      unit_ptr->output = unit_ptr->act;
    else
      /*  no identity output function: calculate unit's output also  */
      unit_ptr->output = (*unit_ptr->out_func) (unit_ptr->act);
  }

}





/*#################################################


   Other User Defined Update Functions

#################################################*/



/*   Counterpropagation Update Function
*/

void normalize_inputvector(float sum )
{
  register struct Unit *unit_ptr;
  register float amount;


  amount = 1.0 / sqrt( sum );

  FOR_ALL_UNITS( unit_ptr )
    if(unit_ptr->flags & UFLAG_TTYP_IN)
      /* this is a input unit */
      unit_ptr->output = unit_ptr->output * amount;
}


void  UPDATE_CPNPropagate()
{
  register struct Unit   *unit_ptr, *winner_ptr;
  register struct Site   *site_ptr;
  register struct Link   *link_ptr;
  register TopoPtrArray  topo_ptr;

  float maximum, unit_ptr_net, sum;
  int  ret_code;


  topo_ptr = topo_ptr_array;
  sum = 0.0;

  /*  propagagate all input units  */
  while ((unit_ptr = *++topo_ptr) != NULL)
    {  /*  this is a input unit     */
    unit_ptr->output = unit_ptr->act;
    sum += unit_ptr->output * unit_ptr->output;
    }

   if (sum != 0.0)
     /* normalize the inputvector */
     normalize_inputvector( sum );


  /***************************************************************/
  /*              propagate Kohonen Layer                        */
  /***************************************************************/

  /***************************************************************/
  /*      calculate the activation and the output values         */
  /*      of the hidden units (Kohonen Layer)                    */
  /***************************************************************/

  winner_ptr = NULL;
  maximum = -1.0e30;  /* contains the maximum of the activations */

  /*  propagagate all hidden units  */
  while ((unit_ptr = *++topo_ptr) != NULL)
    {   /* this is a hidden unit */
    unit_ptr_net = 0.0;

    if (unit_ptr->flags & UFLAG_SITES)
      { /* the unit has sites */
      FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
	  unit_ptr_net += (link_ptr->weight * link_ptr->to->output);
      }
    else
      {  /* the unit has direct links */
      FOR_ALL_LINKS( unit_ptr, link_ptr )
	unit_ptr_net += (link_ptr->weight * link_ptr->to->output);
      }

    if (maximum < unit_ptr_net)
      {  /*  determine winner unit  */
      winner_ptr = unit_ptr;
      maximum = unit_ptr_net;
      }

    /*  reset output and activation of hidden units  */
    unit_ptr->output = unit_ptr->act = (FlintType) 0;
    }

  /***************************************************************/
  /*             the competitive winner is chosen                */
  /***************************************************************/
  winner_ptr->output = winner_ptr->act = (FlintType) 1;


  /* propagate the Grossberg Layer */

  /*  propagagate all output units  */
  while ((unit_ptr = *++topo_ptr) != NULL)
    { /* this is a output unit */
    /* the activation function is the identity function ( weighted sum) */
    unit_ptr->output = unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
    }

}
